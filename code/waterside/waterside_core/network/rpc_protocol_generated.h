// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RPCPROTOCOL_WATERSIDE_H_
#define FLATBUFFERS_GENERATED_RPCPROTOCOL_WATERSIDE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace waterside {

struct RpcPacketHeader;

struct RpcPacketConnectReply;
struct RpcPacketConnectReplyBuilder;

enum MESSAGE_PACKET_TYPE : uint8_t {
  MESSAGE_PACKET_TYPE_PING = 0,
  MESSAGE_PACKET_TYPE_DISCONNECT = 1,
  MESSAGE_PACKET_TYPE_MESSAGE = 2,
  MESSAGE_PACKET_TYPE_RPC_REQUEST = 3,
  MESSAGE_PACKET_TYPE_RPC_RESPONSE = 4,
  MESSAGE_PACKET_TYPE_MYSQL = 5,
  MESSAGE_PACKET_TYPE_MIN = MESSAGE_PACKET_TYPE_PING,
  MESSAGE_PACKET_TYPE_MAX = MESSAGE_PACKET_TYPE_MYSQL
};

inline const MESSAGE_PACKET_TYPE (&EnumValuesMESSAGE_PACKET_TYPE())[6] {
  static const MESSAGE_PACKET_TYPE values[] = {
    MESSAGE_PACKET_TYPE_PING,
    MESSAGE_PACKET_TYPE_DISCONNECT,
    MESSAGE_PACKET_TYPE_MESSAGE,
    MESSAGE_PACKET_TYPE_RPC_REQUEST,
    MESSAGE_PACKET_TYPE_RPC_RESPONSE,
    MESSAGE_PACKET_TYPE_MYSQL
  };
  return values;
}

inline const char * const *EnumNamesMESSAGE_PACKET_TYPE() {
  static const char * const names[7] = {
    "PING",
    "DISCONNECT",
    "MESSAGE",
    "RPC_REQUEST",
    "RPC_RESPONSE",
    "MYSQL",
    nullptr
  };
  return names;
}

inline const char *EnumNameMESSAGE_PACKET_TYPE(MESSAGE_PACKET_TYPE e) {
  if (::flatbuffers::IsOutRange(e, MESSAGE_PACKET_TYPE_PING, MESSAGE_PACKET_TYPE_MYSQL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMESSAGE_PACKET_TYPE()[index];
}

enum SERIALIZATION_TYPE : uint8_t {
  SERIALIZATION_TYPE_NO = 0,
  SERIALIZATION_TYPE_STRUCT_PACK = 1,
  SERIALIZATION_TYPE_FLAT_BUFFERS = 2,
  SERIALIZATION_TYPE_MIN = SERIALIZATION_TYPE_NO,
  SERIALIZATION_TYPE_MAX = SERIALIZATION_TYPE_FLAT_BUFFERS
};

inline const SERIALIZATION_TYPE (&EnumValuesSERIALIZATION_TYPE())[3] {
  static const SERIALIZATION_TYPE values[] = {
    SERIALIZATION_TYPE_NO,
    SERIALIZATION_TYPE_STRUCT_PACK,
    SERIALIZATION_TYPE_FLAT_BUFFERS
  };
  return values;
}

inline const char * const *EnumNamesSERIALIZATION_TYPE() {
  static const char * const names[4] = {
    "NO",
    "STRUCT_PACK",
    "FLAT_BUFFERS",
    nullptr
  };
  return names;
}

inline const char *EnumNameSERIALIZATION_TYPE(SERIALIZATION_TYPE e) {
  if (::flatbuffers::IsOutRange(e, SERIALIZATION_TYPE_NO, SERIALIZATION_TYPE_FLAT_BUFFERS)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSERIALIZATION_TYPE()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) RpcPacketHeader FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t packet_type_;
  uint8_t serialize_type_;
  uint16_t length_;
  uint32_t seq_num_;
  uint32_t function_id_;

 public:
  RpcPacketHeader()
      : packet_type_(0),
        serialize_type_(0),
        length_(0),
        seq_num_(0),
        function_id_(0) {
  }
  RpcPacketHeader(waterside::MESSAGE_PACKET_TYPE _packet_type, waterside::SERIALIZATION_TYPE _serialize_type, uint16_t _length, uint32_t _seq_num, uint32_t _function_id)
      : packet_type_(::flatbuffers::EndianScalar(static_cast<uint8_t>(_packet_type))),
        serialize_type_(::flatbuffers::EndianScalar(static_cast<uint8_t>(_serialize_type))),
        length_(::flatbuffers::EndianScalar(_length)),
        seq_num_(::flatbuffers::EndianScalar(_seq_num)),
        function_id_(::flatbuffers::EndianScalar(_function_id)) {
  }
  /// message packet type
  waterside::MESSAGE_PACKET_TYPE packet_type() const {
    return static_cast<waterside::MESSAGE_PACKET_TYPE>(::flatbuffers::EndianScalar(packet_type_));
  }
  void mutate_packet_type(waterside::MESSAGE_PACKET_TYPE _packet_type) {
    ::flatbuffers::WriteScalar(&packet_type_, static_cast<uint8_t>(_packet_type));
  }
  /// serialization type
  waterside::SERIALIZATION_TYPE serialize_type() const {
    return static_cast<waterside::SERIALIZATION_TYPE>(::flatbuffers::EndianScalar(serialize_type_));
  }
  void mutate_serialize_type(waterside::SERIALIZATION_TYPE _serialize_type) {
    ::flatbuffers::WriteScalar(&serialize_type_, static_cast<uint8_t>(_serialize_type));
  }
  /// length of RPC body
  uint16_t length() const {
    return ::flatbuffers::EndianScalar(length_);
  }
  void mutate_length(uint16_t _length) {
    ::flatbuffers::WriteScalar(&length_, _length);
  }
  /// sequence number
  uint32_t seq_num() const {
    return ::flatbuffers::EndianScalar(seq_num_);
  }
  void mutate_seq_num(uint32_t _seq_num) {
    ::flatbuffers::WriteScalar(&seq_num_, _seq_num);
  }
  /// rpc function ID
  uint32_t function_id() const {
    return ::flatbuffers::EndianScalar(function_id_);
  }
  void mutate_function_id(uint32_t _function_id) {
    ::flatbuffers::WriteScalar(&function_id_, _function_id);
  }
};
FLATBUFFERS_STRUCT_END(RpcPacketHeader, 12);

struct RpcPacketConnectReply FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RpcPacketConnectReplyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADDRESS = 4,
    VT_PORT = 6,
    VT_CONV = 8
  };
  const ::flatbuffers::String *address() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ADDRESS);
  }
  ::flatbuffers::String *mutable_address() {
    return GetPointer<::flatbuffers::String *>(VT_ADDRESS);
  }
  uint32_t port() const {
    return GetField<uint32_t>(VT_PORT, 0);
  }
  bool mutate_port(uint32_t _port = 0) {
    return SetField<uint32_t>(VT_PORT, _port, 0);
  }
  uint32_t conv() const {
    return GetField<uint32_t>(VT_CONV, 0);
  }
  bool mutate_conv(uint32_t _conv = 0) {
    return SetField<uint32_t>(VT_CONV, _conv, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ADDRESS) &&
           verifier.VerifyString(address()) &&
           VerifyField<uint32_t>(verifier, VT_PORT, 4) &&
           VerifyField<uint32_t>(verifier, VT_CONV, 4) &&
           verifier.EndTable();
  }
};

struct RpcPacketConnectReplyBuilder {
  typedef RpcPacketConnectReply Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_address(::flatbuffers::Offset<::flatbuffers::String> address) {
    fbb_.AddOffset(RpcPacketConnectReply::VT_ADDRESS, address);
  }
  void add_port(uint32_t port) {
    fbb_.AddElement<uint32_t>(RpcPacketConnectReply::VT_PORT, port, 0);
  }
  void add_conv(uint32_t conv) {
    fbb_.AddElement<uint32_t>(RpcPacketConnectReply::VT_CONV, conv, 0);
  }
  explicit RpcPacketConnectReplyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RpcPacketConnectReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RpcPacketConnectReply>(end);
    fbb_.Required(o, RpcPacketConnectReply::VT_ADDRESS);
    return o;
  }
};

inline ::flatbuffers::Offset<RpcPacketConnectReply> CreateRpcPacketConnectReply(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> address = 0,
    uint32_t port = 0,
    uint32_t conv = 0) {
  RpcPacketConnectReplyBuilder builder_(_fbb);
  builder_.add_conv(conv);
  builder_.add_port(port);
  builder_.add_address(address);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RpcPacketConnectReply> CreateRpcPacketConnectReplyDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *address = nullptr,
    uint32_t port = 0,
    uint32_t conv = 0) {
  auto address__ = address ? _fbb.CreateString(address) : 0;
  return waterside::CreateRpcPacketConnectReply(
      _fbb,
      address__,
      port,
      conv);
}

}  // namespace waterside

#endif  // FLATBUFFERS_GENERATED_RPCPROTOCOL_WATERSIDE_H_
