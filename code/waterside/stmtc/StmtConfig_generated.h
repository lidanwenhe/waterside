// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_STMTCONFIG_H_
#define FLATBUFFERS_GENERATED_STMTCONFIG_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

struct StmtItem;
struct StmtItemBuilder;

struct StmtConfigItem;
struct StmtConfigItemBuilder;

struct StmtConfig;
struct StmtConfigBuilder;

enum STMT_TYPE : uint8_t {
  STMT_TYPE_BYTE = 0,
  STMT_TYPE_UBYTE = 1,
  STMT_TYPE_SHORT = 2,
  STMT_TYPE_USHORT = 3,
  STMT_TYPE_INT = 4,
  STMT_TYPE_UINT = 5,
  STMT_TYPE_LONG = 6,
  STMT_TYPE_ULONG = 7,
  STMT_TYPE_FLOAT = 8,
  STMT_TYPE_DOUBLE = 9,
  STMT_TYPE_STRING = 10,
  STMT_TYPE_VARSTRING = 11,
  STMT_TYPE_TINYBLOB = 12,
  STMT_TYPE_BLOB = 13,
  STMT_TYPE_MEDIUMBLOB = 14,
  STMT_TYPE_TIMESTAMP = 15,
  STMT_TYPE_MIN = STMT_TYPE_BYTE,
  STMT_TYPE_MAX = STMT_TYPE_TIMESTAMP
};

inline const STMT_TYPE (&EnumValuesSTMT_TYPE())[16] {
  static const STMT_TYPE values[] = {
    STMT_TYPE_BYTE,
    STMT_TYPE_UBYTE,
    STMT_TYPE_SHORT,
    STMT_TYPE_USHORT,
    STMT_TYPE_INT,
    STMT_TYPE_UINT,
    STMT_TYPE_LONG,
    STMT_TYPE_ULONG,
    STMT_TYPE_FLOAT,
    STMT_TYPE_DOUBLE,
    STMT_TYPE_STRING,
    STMT_TYPE_VARSTRING,
    STMT_TYPE_TINYBLOB,
    STMT_TYPE_BLOB,
    STMT_TYPE_MEDIUMBLOB,
    STMT_TYPE_TIMESTAMP
  };
  return values;
}

inline const char * const *EnumNamesSTMT_TYPE() {
  static const char * const names[17] = {
    "BYTE",
    "UBYTE",
    "SHORT",
    "USHORT",
    "INT",
    "UINT",
    "LONG",
    "ULONG",
    "FLOAT",
    "DOUBLE",
    "STRING",
    "VARSTRING",
    "TINYBLOB",
    "BLOB",
    "MEDIUMBLOB",
    "TIMESTAMP",
    nullptr
  };
  return names;
}

inline const char *EnumNameSTMT_TYPE(STMT_TYPE e) {
  if (::flatbuffers::IsOutRange(e, STMT_TYPE_BYTE, STMT_TYPE_TIMESTAMP)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSTMT_TYPE()[index];
}

enum STMT_CALLBACK : uint8_t {
  /// 没有回调，自己实现
  STMT_CALLBACK_NO = 0,
  /// insert，update...
  STMT_CALLBACK_RETURN_VOID = 1,
  /// select 1
  STMT_CALLBACK_RETURN = 2,
  /// select n
  STMT_CALLBACK_RETURN_LIST = 3,
  STMT_CALLBACK_MIN = STMT_CALLBACK_NO,
  STMT_CALLBACK_MAX = STMT_CALLBACK_RETURN_LIST
};

inline const STMT_CALLBACK (&EnumValuesSTMT_CALLBACK())[4] {
  static const STMT_CALLBACK values[] = {
    STMT_CALLBACK_NO,
    STMT_CALLBACK_RETURN_VOID,
    STMT_CALLBACK_RETURN,
    STMT_CALLBACK_RETURN_LIST
  };
  return values;
}

inline const char * const *EnumNamesSTMT_CALLBACK() {
  static const char * const names[5] = {
    "NO",
    "RETURN_VOID",
    "RETURN",
    "RETURN_LIST",
    nullptr
  };
  return names;
}

inline const char *EnumNameSTMT_CALLBACK(STMT_CALLBACK e) {
  if (::flatbuffers::IsOutRange(e, STMT_CALLBACK_NO, STMT_CALLBACK_RETURN_LIST)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSTMT_CALLBACK()[index];
}

struct StmtItem FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StmtItemBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_BIND_TYPE = 6,
    VT_BUF_SIZE = 8,
    VT_MAYBE_NULL = 10
  };
  /// 名字
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// 绑定类型
  STMT_TYPE bind_type() const {
    return static_cast<STMT_TYPE>(GetField<uint8_t>(VT_BIND_TYPE, 0));
  }
  /// 缓存大小。字符串才有效
  uint32_t buf_size() const {
    return GetField<uint32_t>(VT_BUF_SIZE, 0);
  }
  /// 允许为空。时间戳、字符串才有效
  bool maybe_null() const {
    return GetField<uint8_t>(VT_MAYBE_NULL, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_BIND_TYPE, 1) &&
           VerifyField<uint32_t>(verifier, VT_BUF_SIZE, 4) &&
           VerifyField<uint8_t>(verifier, VT_MAYBE_NULL, 1) &&
           verifier.EndTable();
  }
};

struct StmtItemBuilder {
  typedef StmtItem Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(StmtItem::VT_NAME, name);
  }
  void add_bind_type(STMT_TYPE bind_type) {
    fbb_.AddElement<uint8_t>(StmtItem::VT_BIND_TYPE, static_cast<uint8_t>(bind_type), 0);
  }
  void add_buf_size(uint32_t buf_size) {
    fbb_.AddElement<uint32_t>(StmtItem::VT_BUF_SIZE, buf_size, 0);
  }
  void add_maybe_null(bool maybe_null) {
    fbb_.AddElement<uint8_t>(StmtItem::VT_MAYBE_NULL, static_cast<uint8_t>(maybe_null), 0);
  }
  explicit StmtItemBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StmtItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StmtItem>(end);
    fbb_.Required(o, StmtItem::VT_NAME);
    return o;
  }
};

inline ::flatbuffers::Offset<StmtItem> CreateStmtItem(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    STMT_TYPE bind_type = STMT_TYPE_BYTE,
    uint32_t buf_size = 0,
    bool maybe_null = false) {
  StmtItemBuilder builder_(_fbb);
  builder_.add_buf_size(buf_size);
  builder_.add_name(name);
  builder_.add_maybe_null(maybe_null);
  builder_.add_bind_type(bind_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StmtItem> CreateStmtItemDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    STMT_TYPE bind_type = STMT_TYPE_BYTE,
    uint32_t buf_size = 0,
    bool maybe_null = false) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return CreateStmtItem(
      _fbb,
      name__,
      bind_type,
      buf_size,
      maybe_null);
}

struct StmtConfigItem FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StmtConfigItemBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4,
    VT_SQL = 6,
    VT_PARAMS = 8,
    VT_RESULTS = 10,
    VT_CB = 12
  };
  /// 索引
  const ::flatbuffers::String *index() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INDEX);
  }
  /// sql语句
  const ::flatbuffers::String *sql() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SQL);
  }
  /// 参数
  const ::flatbuffers::Vector<::flatbuffers::Offset<StmtItem>> *params() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<StmtItem>> *>(VT_PARAMS);
  }
  /// 返回值
  const ::flatbuffers::Vector<::flatbuffers::Offset<StmtItem>> *results() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<StmtItem>> *>(VT_RESULTS);
  }
  /// 实现默认回调函数
  STMT_CALLBACK cb() const {
    return static_cast<STMT_CALLBACK>(GetField<uint8_t>(VT_CB, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_INDEX) &&
           verifier.VerifyString(index()) &&
           VerifyOffsetRequired(verifier, VT_SQL) &&
           verifier.VerifyString(sql()) &&
           VerifyOffset(verifier, VT_PARAMS) &&
           verifier.VerifyVector(params()) &&
           verifier.VerifyVectorOfTables(params()) &&
           VerifyOffset(verifier, VT_RESULTS) &&
           verifier.VerifyVector(results()) &&
           verifier.VerifyVectorOfTables(results()) &&
           VerifyField<uint8_t>(verifier, VT_CB, 1) &&
           verifier.EndTable();
  }
};

struct StmtConfigItemBuilder {
  typedef StmtConfigItem Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_index(::flatbuffers::Offset<::flatbuffers::String> index) {
    fbb_.AddOffset(StmtConfigItem::VT_INDEX, index);
  }
  void add_sql(::flatbuffers::Offset<::flatbuffers::String> sql) {
    fbb_.AddOffset(StmtConfigItem::VT_SQL, sql);
  }
  void add_params(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<StmtItem>>> params) {
    fbb_.AddOffset(StmtConfigItem::VT_PARAMS, params);
  }
  void add_results(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<StmtItem>>> results) {
    fbb_.AddOffset(StmtConfigItem::VT_RESULTS, results);
  }
  void add_cb(STMT_CALLBACK cb) {
    fbb_.AddElement<uint8_t>(StmtConfigItem::VT_CB, static_cast<uint8_t>(cb), 0);
  }
  explicit StmtConfigItemBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StmtConfigItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StmtConfigItem>(end);
    fbb_.Required(o, StmtConfigItem::VT_INDEX);
    fbb_.Required(o, StmtConfigItem::VT_SQL);
    return o;
  }
};

inline ::flatbuffers::Offset<StmtConfigItem> CreateStmtConfigItem(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> index = 0,
    ::flatbuffers::Offset<::flatbuffers::String> sql = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<StmtItem>>> params = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<StmtItem>>> results = 0,
    STMT_CALLBACK cb = STMT_CALLBACK_NO) {
  StmtConfigItemBuilder builder_(_fbb);
  builder_.add_results(results);
  builder_.add_params(params);
  builder_.add_sql(sql);
  builder_.add_index(index);
  builder_.add_cb(cb);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StmtConfigItem> CreateStmtConfigItemDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *index = nullptr,
    const char *sql = nullptr,
    const std::vector<::flatbuffers::Offset<StmtItem>> *params = nullptr,
    const std::vector<::flatbuffers::Offset<StmtItem>> *results = nullptr,
    STMT_CALLBACK cb = STMT_CALLBACK_NO) {
  auto index__ = index ? _fbb.CreateString(index) : 0;
  auto sql__ = sql ? _fbb.CreateString(sql) : 0;
  auto params__ = params ? _fbb.CreateVector<::flatbuffers::Offset<StmtItem>>(*params) : 0;
  auto results__ = results ? _fbb.CreateVector<::flatbuffers::Offset<StmtItem>>(*results) : 0;
  return CreateStmtConfigItem(
      _fbb,
      index__,
      sql__,
      params__,
      results__,
      cb);
}

struct StmtConfig FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StmtConfigBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PACKAGE = 4,
    VT_CLASS_NAME = 6,
    VT_ALL = 8
  };
  /// 包名
  const ::flatbuffers::String *package() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PACKAGE);
  }
  /// 类名
  const ::flatbuffers::String *class_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASS_NAME);
  }
  /// 数据库生成配置
  const ::flatbuffers::Vector<::flatbuffers::Offset<StmtConfigItem>> *all() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<StmtConfigItem>> *>(VT_ALL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PACKAGE) &&
           verifier.VerifyString(package()) &&
           VerifyOffsetRequired(verifier, VT_CLASS_NAME) &&
           verifier.VerifyString(class_name()) &&
           VerifyOffsetRequired(verifier, VT_ALL) &&
           verifier.VerifyVector(all()) &&
           verifier.VerifyVectorOfTables(all()) &&
           verifier.EndTable();
  }
};

struct StmtConfigBuilder {
  typedef StmtConfig Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_package(::flatbuffers::Offset<::flatbuffers::String> package) {
    fbb_.AddOffset(StmtConfig::VT_PACKAGE, package);
  }
  void add_class_name(::flatbuffers::Offset<::flatbuffers::String> class_name) {
    fbb_.AddOffset(StmtConfig::VT_CLASS_NAME, class_name);
  }
  void add_all(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<StmtConfigItem>>> all) {
    fbb_.AddOffset(StmtConfig::VT_ALL, all);
  }
  explicit StmtConfigBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StmtConfig> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StmtConfig>(end);
    fbb_.Required(o, StmtConfig::VT_CLASS_NAME);
    fbb_.Required(o, StmtConfig::VT_ALL);
    return o;
  }
};

inline ::flatbuffers::Offset<StmtConfig> CreateStmtConfig(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> package = 0,
    ::flatbuffers::Offset<::flatbuffers::String> class_name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<StmtConfigItem>>> all = 0) {
  StmtConfigBuilder builder_(_fbb);
  builder_.add_all(all);
  builder_.add_class_name(class_name);
  builder_.add_package(package);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StmtConfig> CreateStmtConfigDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *package = nullptr,
    const char *class_name = nullptr,
    const std::vector<::flatbuffers::Offset<StmtConfigItem>> *all = nullptr) {
  auto package__ = package ? _fbb.CreateString(package) : 0;
  auto class_name__ = class_name ? _fbb.CreateString(class_name) : 0;
  auto all__ = all ? _fbb.CreateVector<::flatbuffers::Offset<StmtConfigItem>>(*all) : 0;
  return CreateStmtConfig(
      _fbb,
      package__,
      class_name__,
      all__);
}

inline const StmtConfig *GetStmtConfig(const void *buf) {
  return ::flatbuffers::GetRoot<StmtConfig>(buf);
}

inline const StmtConfig *GetSizePrefixedStmtConfig(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<StmtConfig>(buf);
}

inline bool VerifyStmtConfigBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<StmtConfig>(nullptr);
}

inline bool VerifySizePrefixedStmtConfigBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<StmtConfig>(nullptr);
}

inline void FinishStmtConfigBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<StmtConfig> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedStmtConfigBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<StmtConfig> root) {
  fbb.FinishSizePrefixed(root);
}

#endif  // FLATBUFFERS_GENERATED_STMTCONFIG_H_
